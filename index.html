<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>M√©t√©o Marine - R√©gion Boeny</title>
  <link rel="icon" type="image/x-icon" href="image/favicon.ico">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Try multiple CDN sources for leaflet-velocity -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet-velocity@1.4.1/dist/leaflet-velocity.min.js" onerror="loadVelocityFallback()"></script>
  <style>
    :root {
      --primary-bg: rgba(255, 255, 255, 0.95);
      --secondary-bg: rgba(248, 250, 252, 0.98);
      --accent-color: #3b82f6;
      --text-primary: #1f2937;
      --text-secondary: #6b7280;
      --shadow: 0 10px 25px rgba(0,0,0,.15);
      --shadow-sm: 0 4px 12px rgba(0,0,0,.08);
      --border-radius: 16px;
      --border-radius-sm: 12px;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      color: var(--text-primary);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    
    #map { 
      height: 100vh; 
      width: 100%; 
      position: relative;
    }
    
    /* Enhanced Control Panel */
    .panel {
      position: absolute; 
      left: 16px; 
      top: 16px; 
      z-index: 1000;
      background: var(--primary-bg); 
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 20px; 
      border-radius: var(--border-radius); 
      box-shadow: var(--shadow);
      min-width: 280px;
      max-width: 320px;
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .panel.collapsed {
      transform: translateX(-75%);
      opacity: 0.9;
    }
    
    .panel h3 { 
      margin: 0 0 16px; 
      font-size: 18px; 
      font-weight: 700;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .stats { 
      font-size: 14px; 
      line-height: 1.6; 
      margin: 16px 0;
      padding: 16px;
      background: var(--secondary-bg);
      border-radius: var(--border-radius-sm);
      border: 1px solid rgba(0,0,0,0.05);
    }
    
    .row { 
      display: flex; 
      gap: 12px; 
      align-items: center; 
      margin: 12px 0;
      flex-wrap: wrap;
    }
    
    .btn {
      border: 0; 
      border-radius: var(--border-radius-sm); 
      padding: 12px 16px; 
      cursor: pointer;
      box-shadow: var(--shadow-sm); 
      background: #fff;
      font-weight: 600; 
      font-size: 14px;
      color: var(--text-primary);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      min-height: 44px; /* Better touch targets */
    }
    
    .btn:hover:not(:disabled) { 
      transform: translateY(-2px); 
      box-shadow: 0 8px 20px rgba(0,0,0,.15);
      background: #f8fafc;
    }
    
    .btn:active:not(:disabled) {
      transform: translateY(0);
    }
    
    .btn.primary {
      background: var(--accent-color);
      color: white;
    }
    
    .btn.primary:hover:not(:disabled) {
      background: #2563eb;
    }
    
    .btn:disabled { 
      opacity: 0.6; 
      cursor: not-allowed; 
      transform: none !important;
    }
    
    .badge { 
      display: inline-flex;
      align-items: center;
      padding: 6px 12px; 
      border-radius: 20px; 
      background: #eff6ff; 
      font-size: 12px;
      font-weight: 500;
      color: var(--accent-color);
      border: 1px solid rgba(59, 130, 246, 0.2);
    }
    
    .legend { 
      position: absolute; 
      right: 16px; 
      bottom: 16px; 
      z-index: 1000; 
      background: var(--primary-bg); 
      border-radius: var(--border-radius-sm); 
      box-shadow: var(--shadow); 
      padding: 16px; 
      font-size: 13px;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.2);
      max-width: 200px;
    }
    
    .spinner { 
      width: 18px; 
      height: 18px; 
      border: 2px solid #e5e7eb; 
      border-top-color: var(--accent-color); 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      display: inline-block; 
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }
    
    .toast { 
      position: absolute; 
      left: 50%; 
      transform: translateX(-50%); 
      top: 20px; 
      z-index: 1100; 
      background: rgba(17, 24, 39, 0.95); 
      color: #fff; 
      padding: 12px 20px; 
      border-radius: var(--border-radius-sm); 
      box-shadow: var(--shadow); 
      display: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-size: 14px;
      font-weight: 500;
    }
    
    .toggle-panel {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1001;
      background: var(--primary-bg);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }
    
    select {
      appearance: none;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: var(--border-radius-sm);
      padding: 12px 16px;
      font-size: 14px;
      cursor: pointer;
      min-width: 80px;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 12px center;
      background-repeat: no-repeat;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .control-label {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      #map {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
      }
      .panel {
        left: 0;
        top: 0;
        right: 0;
        min-width: unset;
        max-width: unset;
        width: 100vw;
        padding: 12px;
        z-index: 1002;
        box-sizing: border-box;
        border-radius: 0 0 var(--border-radius) var(--border-radius);
      }
      .panel.collapsed {
        transform: translateY(-90%);
        opacity: 0.9;
      }
      .legend {
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        max-width: unset;
        z-index: 1002;
        box-sizing: border-box;
        border-radius: var(--border-radius) var(--border-radius) 0 0;
        padding: 12px;
      }
      .row {
        flex-direction: column;
        align-items: stretch;
      }
      .btn {
        justify-content: center;
        width: 100%;
      }
      .toggle-panel {
        display: flex;
        top: 12px;
        left: auto;
        right: 12px;
        transform: none;
        z-index: 1003;
      }
    }
    
    @media (max-width: 480px) {
      .panel {
        font-size: 14px;
      }
      
      .panel h3 {
        font-size: 16px;
      }
      
      .stats {
        font-size: 13px;
      }
    }

    .leaflet-control-zoom {
      z-index: 1100 !important;
    }

    @media (max-width: 768px) {
      .leaflet-control-zoom {
        top: 70px !important; /* d√©cale les boutons sous le panel */
        left: 12px !important;
        right: auto !important;
        position: absolute !important;
        z-index: 1100 !important;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <button class="toggle-panel" id="toggle-panel">‚ò∞</button>

  <div class="panel" id="control-panel">
    <h3>
      <span>üåä</span>
      M√©t√©o Marine ‚Äî Mahajanga
    </h3>
    
    <div class="stats" id="weather-info">
      Chargement des donn√©es‚Ä¶ <span class="spinner"></span>
    </div>
    
    <div class="row">
      <button class="btn primary" id="refresh-btn">
        <span>üîÑ</span>
        Actualiser
      </button>
      <div class="badge" id="timestamp">--:--</div>
    </div>
    
    <div class="control-group">
      <label class="control-label" for="density">R√©solution de la grille</label>
      <div class="row">
        <select id="density" class="btn">
          <option value="8">8√ó8 (Standard)</option>
          <option value="10" selected>10√ó10 (Dense)</option>
          <option value="12">12√ó12 (Tr√®s dense)</option>
          <option value="15">15√ó15 (Maximum)</option>
        </select>
        <button class="btn" id="apply-grid">Appliquer</button>
      </div>
    </div>

    <div class="control-group">
      <div class="row">
        <button class="btn" id="toggle-animation">‚è∏Ô∏è Pause</button>
        <button class="btn" id="fullscreen-btn">‚õ∂ Plein √©cran</button>
      </div>
    </div>
  </div>

  <div class="legend">
    <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">L√©gende des vents</div>
    <div style="font-size: 12px; line-height: 1.4;">
      <div>‚Ä¢ Particules anim√©es = direction du vent</div>
      <div>‚Ä¢ Couleurs des fl√®ches ou particules :</div>
      <div style="margin-left: 12px;">
        <span style="color: #3288bd;">Bleu</span> = vent faible<br>
        <span style="color: #fee08b;">Jaune</span> = vent mod√©r√©<br>
        <span style="color: #f46d43;">Orange</span> = vent fort<br>
        <span style="color: #d53e4f;">Rouge</span> = vent tr√®s fort
      </div>
      <div style="margin-top: 8px;">‚Ä¢ Zone couverte : Ville de Mahajanga</div>
    </div>
    <div style="font-size: 11px; opacity: 0.7; margin-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 8px;">
      Source: Open-Meteo API ‚Ä¢ Mahajanga, Madagascar
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // --- Localisation / Traductions (fr par d√©faut, support de base pour mg) ---
    const LANG = 'fr'; // change to 'mg' to test Malagasy
    const TEXT = {
      fr: {
        tryingCdn: "Tentative de chargement du CDN alternatif pour leaflet-velocity‚Ä¶",
        allCdnFailed: "Tous les CDN ont √©chou√© ‚Äî utilisation de la visualisation personnalis√©e des vents",
        detailedError: "Erreur d√©taill√©e:",
        cacheReadFailed: "Lecture du cache √©chou√©e",
        cacheWriteFailed: "√âchec de l'√©criture du cache",
        pointFetchError: "Erreur lors de la r√©cup√©ration d'un point",
        windData: "Donn√©es vent:",
        maxVelocity: "Vitesse max:",
        velocityAdded: "Couche vent ajout√©e √† la carte",
        velocityFailed: "La couche velocity a √©chou√©:",
        usingCustom: "Utilisation de la visualisation de secours (personnalis√©e)",
        tryingAltCdn: "Essai d'un CDN alternatif pour leaflet-velocity‚Ä¶"
      },
      mg: {
        tryingCdn: "Miezaka mampakatra CDN hafa ho an'ny leaflet-velocity‚Ä¶",
        allCdnFailed: "Tsy nahomby ny CDN rehetra ‚Äî mampiasa sary rivotra mahazatra",
        detailedError: "Lesona fahadisoana:",
        cacheReadFailed: "Tsy afaka namaky ny cache",
        cacheWriteFailed: "Tsy afaka nanoratra ny cache",
        pointFetchError: "Diso tamin'ny fakana teboka",
        windData: "Angon'ny rivotra:",
        maxVelocity: "Hafainganam-pandeha ambony indrindra:",
        velocityAdded: "Nampiana sarimihetsika rivotra tamin'ny sarintany",
        velocityFailed: "Tsy nety ny sosona velocity:",
        usingCustom: "Mampiasa fomba fijery hafa (compatibilit√©)"
      }
    };
    function t(key) { return (TEXT[LANG] && TEXT[LANG][key]) || key; }
    // --- end localisation ---

    // Fallback function to load velocity library from alternative sources
    function loadVelocityFallback() {
      console.log(t('tryingCdn'));
      const script = document.createElement('script');
      script.src = 'https://unpkg.com/leaflet-velocity@1.4.1/dist/leaflet-velocity.min.js';
      script.onerror = function() {
        console.log(t('allCdnFailed'));
        window.velocityLibraryFailed = true;
      };
      document.head.appendChild(script);
    }
 
    // Custom wind visualization when velocity library is not available
    function createCustomWindLayer(windData, maxVelocity, options = {}) {
      if (!windData || windData.length < 2) return null;
      const uData = windData[0].data || [];
      const vData = windData[1].data || [];
      const header = windData[0].header || {};

      const particleMultiplier = options.particleMultiplier ?? 1 / 200; // controls particle count relative to canvas area
      const maxParticles = options.maxParticles ?? 2000;
      const sampleStep = Math.max(1, options.sampleStep ?? 1); // use all points by default; set >1 to skip for perf
      const fadeAlpha = options.fadeAlpha ?? 0.03;
      const speedScale = options.speedScale ?? 1.0;

      // bilinear sample of (u,v) given lat,lon
      function sampleUV(lat, lon) {
        const la1 = Number(header.la1);
        const lo1 = Number(header.lo1);
        const dx = Number(header.dx) || 0.01;
        const dy = Number(header.dy) || -0.01; // may be negative
        const nx = Number(header.nx) || Math.sqrt(uData.length) || 1;
        const ny = Number(header.ny) || Math.sqrt(uData.length) || 1;

        const rowF = (la1 - lat) / Math.abs(dy);
        const colF = (lon - lo1) / dx;
        const r0 = Math.floor(rowF), c0 = Math.floor(colF);
        const r1 = Math.min(ny - 1, r0 + 1), c1 = Math.min(nx - 1, c0 + 1);
        const fr = rowF - r0, fc = colF - c0;
        function get(arr, r, c) {
          const idx = (r * nx + c);
          return arr[idx] ?? 0;
        }
        const u00 = get(uData, r0, c0), u10 = get(uData, r0, c1), u01 = get(uData, r1, c0), u11 = get(uData, r1, c1);
        const v00 = get(vData, r0, c0), v10 = get(vData, r0, c1), v01 = get(vData, r1, c0), v11 = get(vData, r1, c1);
        const u0 = u00 * (1 - fc) + u10 * fc;
        const u1 = u01 * (1 - fc) + u11 * fc;
        const v0 = v00 * (1 - fc) + v10 * fc;
        const v1 = v01 * (1 - fc) + v11 * fc;
        const u = u0 * (1 - fr) + u1 * fr;
        const v = v0 * (1 - fr) + v1 * fr;
        return { u, v };
      }

      const CanvasOverlay = L.Layer.extend({
        initialize: function (opts) {
          L.setOptions(this, opts);
          this._canvas = document.createElement('canvas');
          this._ctx = this._canvas.getContext('2d');
          this._particles = [];
          this._frame = null;
        },

        onAdd: function (map) {
          this._map = map;
          map.getPanes().overlayPane.appendChild(this._canvas);
          this._reset();
          map.on('viewreset zoomend move moveend resize', this._reset, this);
          this._initParticles();
          this._start();
        },

        onRemove: function (map) {
          map.getPanes().overlayPane.removeChild(this._canvas);
          map.off('viewreset zoomend move moveend resize', this._reset, this);
          this._stop();
        },

        _reset: function () {
          const bounds = this._map.getBounds();
          const size = this._map.getSize();
          const topLeft = this._map.latLngToLayerPoint(bounds.getNorthWest());
          this._canvas.width = size.x;
          this._canvas.height = size.y;
          this._canvas.style.width = size.x + 'px';
          this._canvas.style.height = size.y + 'px';
          this._canvas.style.position = 'absolute';
          this._canvas.style.left = topLeft.x + 'px';
          this._canvas.style.top = topLeft.y + 'px';
          this._canvas.style.pointerEvents = 'none';
          // re-init particles on resize to keep density
          this._initParticles();
        },

        _initParticles: function () {
          const area = Math.max(1000, this._canvas.width * this._canvas.height);
          const target = Math.min(maxParticles, Math.round(area * particleMultiplier));
          const particles = this._particles;
          particles.length = 0;
          for (let i = 0; i < target; i++) {
            particles.push(this._createParticle());
          }
        },

        _createParticle: function () {
          // random screen position
          const x = Math.random() * this._canvas.width;
          const y = Math.random() * this._canvas.height;
          return { x, y, age: Math.random() * 100, maxAge: 100 + Math.random() * 100 };
        },

        _start: function () {
          if (this._frame) return;
          const step = (time) => {
            this._frame = requestAnimationFrame(step);
            this._animate();
          };
          this._frame = requestAnimationFrame(step);
        },

        _stop: function () {
          if (this._frame) cancelAnimationFrame(this._frame);
          this._frame = null;
        },

        _animate: function () {
          const ctx = this._ctx;
          const w = this._canvas.width, h = this._canvas.height;
          // draw translucent fade to create trails
          ctx.fillStyle = `rgba(0,0,0,${fadeAlpha})`;
          ctx.globalCompositeOperation = 'destination-out';
          ctx.fillRect(0, 0, w, h);
          ctx.globalCompositeOperation = 'lighter';

          for (let p of this._particles) {
            // convert particle screen pos to lat/lon
            const ll = this._map.layerPointToLatLng([p.x, p.y]);
            const { u, v } = sampleUV(ll.lat, ll.lng);
            // map wind vector to screen movement (simple projection)
            const angle = Math.atan2(u, v);
            const speed = Math.sqrt(u * u + v * v) * speedScale;
            const dx = (Math.sin(angle) * speed) * 0.5;
            const dy = (Math.cos(angle) * speed) * 0.5;
            p.x += dx;
            p.y += dy;
            p.age += 1;
            // wrap / reset if out of bounds or too old
            if (p.x < 0 || p.x >= w || p.y < 0 || p.y >= h || p.age > p.maxAge) {
              Object.assign(p, this._createParticle());
              continue;
            }
            // draw particle
            const intensity = Math.min(1, speed / (maxVelocity || 10));
            const hue = 240 - intensity * 180;
            ctx.strokeStyle = `hsl(${hue},70%,60%)`;
            ctx.lineWidth = Math.max(1, 1.5 * intensity);
            ctx.beginPath();
            ctx.moveTo(p.x - dx, p.y - dy);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
          }
        }
      });

      return new CanvasOverlay();
    }
    // Enhanced map initialization focused on Mahajanga city
    const map = L.map('map', { 
      zoomControl: true,
      attributionControl: true,
      preferCanvas: true // Better performance for animations
    }).setView([-15.7167, 46.3167], 12); // Centered precisely on Mahajanga city, closer zoom

    // Add multiple tile layer options
    const tileLayers = {
      'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }),
      'Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '&copy; <a href="https://www.arcgis.com/">ArcGIS</a>'
      })
    };

    tileLayers['OpenStreetMap'].addTo(map);
    L.control.layers(tileLayers).addTo(map);

    // Mahajanga city bounds - properly centered on the actual city location
    let minLat = -15.18, maxLat = -15.65, minLon = 46.2, maxLon = 46.45;

    // Global state
    let gridSize = 10; // default 10√ó10 for better city coverage
    let velocityLayer = null;
    let autoTimer = null;
    let animationPaused = false;

    const $info = document.getElementById('weather-info');
    const $time = document.getElementById('timestamp');
    const $toast = document.getElementById('toast');
    const $panel = document.getElementById('control-panel');
    const $togglePanel = document.getElementById('toggle-panel');

    // Enhanced toast with better styling
    function toast(msg, ms = 3000, type = 'info') {
      $toast.textContent = msg; 
      $toast.style.display = 'block';
      $toast.style.background = type === 'error' ? 'rgba(239, 68, 68, 0.95)' : 'rgba(17, 24, 39, 0.95)';
      setTimeout(() => $toast.style.display = 'none', ms);
    }

    // Map low-level errors to user-friendly French messages
    function mapErrorToUserMessage(err) {
      // log full details for debugging (localis√©)
      console.error(t('detailedError'), err);

      if (!err) return 'Erreur inconnue. Voir la console pour les d√©tails.';

      // AbortError (timeout)
      if (err.name === 'AbortError') return 'La requ√™te a expir√©. Veuillez r√©essayer.';

      const msg = String(err.message || err);

      if (msg.includes('HTTP')) {
        const codeMatch = msg.match(/HTTP\s*(\d{3})/);
        const code = codeMatch ? Number(codeMatch[1]) : null;
        switch (code) {
          case 429:
            return 'Trop de requ√™tes ‚Äî veuillez r√©essayer plus tard.';
          case 400:
            return 'Requ√™te invalide vers le serveur.';
          case 401:
          case 403:
            return "Acc√®s refus√© par l'API.";
          case 404:
            return "Ressource introuvable (404).";
          case 500:
          case 502:
          case 503:
          case 504:
            return "Erreur serveur ‚Äî veuillez r√©essayer ult√©rieurement.";
          default:
            return `Erreur serveur (${code || 'inconnu'}). Voir la console pour plus de d√©tails.`;
        }
      }

      // network-level failures
      if (msg.toLowerCase().includes('failed to fetch') || msg.toLowerCase().includes('networkerror')) {
        return "Impossible de contacter le serveur m√©t√©o. V√©rifiez votre connexion r√©seau.";
      }

      // fallback
      return 'Erreur lors du chargement des donn√©es ‚Äî voir la console pour les d√©tails.';
    }
    
    function buildGrid(n) {
      const latStep = (maxLat - minLat) / (n - 1);
      const lonStep = (maxLon - minLon) / (n - 1);
      const lats = Array.from({ length: n }, (_, i) => maxLat - i * latStep);
      const lons = Array.from({ length: n }, (_, j) => minLon + j * lonStep);
      return { lats, lons, latStep, lonStep, nx: n, ny: n };
    }

    function uvFromSpeedDir(speed, deg) {
      const rad = (deg * Math.PI) / 180;
      const u = -speed * Math.sin(rad);
      const v = -speed * Math.cos(rad);
      return { u, v };
    }

    async function fetchPoint(lat, lon, controller) {
      const url = new URL('https://api.open-meteo.com/v1/forecast');
      url.search = new URLSearchParams({
        latitude: lat.toFixed(3),
        longitude: lon.toFixed(3),
        hourly: 'wind_speed_10m,wind_direction_10m',
        cell_selection: 'sea', // Focus on marine data for coastal Boeny region
        timezone: 'Indian/Antananarivo'
      }).toString();

      const res = await fetch(url, { signal: controller.signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    // --- LocalStorage cache helpers (simple recent-grid cache) ---
    const CACHE_TTL_MS = 15 * 60 * 1000; // 15 minutes

    function cacheKeyForGrid(n) {
      return `windy_cache:${minLat},${maxLat},${minLon},${maxLon}:n=${n}`;
    }

    function loadCachedGrid(n) {
      try {
        const key = cacheKeyForGrid(n);
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const entry = JSON.parse(raw);
        if (!entry || !entry.ts) return null;
        if ((Date.now() - entry.ts) > CACHE_TTL_MS) {
          localStorage.removeItem(key);
          return null;
        }
        return entry.payload;
      } catch (e) {
        console.warn(t('cacheReadFailed'), e);
        return null;
      }
    }

    function saveCachedGrid(n, payload) {
      try {
        const key = cacheKeyForGrid(n);
        const entry = { ts: Date.now(), payload };
        localStorage.setItem(key, JSON.stringify(entry));
      } catch (e) {
        console.warn(t('cacheWriteFailed'), e);
      }
    }
    // --- end cache helpers ---

    async function fetchGridData(n) {
      // try cache first
      const cached = loadCachedGrid(n);
      if (cached) {
        // show quick info that cached data is used
        $info.innerHTML = `Donn√©es r√©centes en cache ‚Äî affichage instantan√©`;
        return cached;
      }

      const { lats, lons, latStep, lonStep, nx, ny } = buildGrid(n);
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 30000); // Increased timeout

      try {
        // Batch requests to avoid overwhelming the API
        const batchSize = 6;                    // concurrent requests per batch
        const interBatchDelay = 1200;           // 1.2s delay between batches (API-friendly)
        const totalPoints = nx * ny;
        const totalBatches = Math.ceil(totalPoints / batchSize);
        const results = new Array(totalPoints).fill(null);

        let fetchedPoints = 0;

        for (let batch = 0; batch < totalBatches; batch++) {
          const start = batch * batchSize;
          const end = Math.min(start + batchSize, totalPoints);
          const batchPromises = [];

          for (let idx = start; idx < end; idx++) {
            const i = Math.floor(idx / nx);
            const j = idx % nx;
            // use existing fetchPoint (with controller)
            batchPromises.push(
              fetchPoint(lats[i], lons[j], controller)
                .then(data => ({ idx, data }))
                .catch(err => ({ idx, err }))
            );
          }

          // update UI progress
          $info.innerHTML = `Chargement des donn√©es‚Ä¶ Traitement du batch ${batch + 1} / ${totalBatches} (<strong>${fetchedPoints}/${totalPoints}</strong> points) <span class="spinner"></span>`;

          const batchResults = await Promise.all(batchPromises);
          for (const r of batchResults) {
            if (r && r.err) {
              console.warn(t('pointFetchError'), r.err);
              results[r.idx] = null;
            } else {
              results[r.idx] = r.data;
              fetchedPoints++;
            }
          }

          // brief pause between batches to respect rate limits
          if (batch < totalBatches - 1) {
            await new Promise(resolve => setTimeout(resolve, interBatchDelay));
          }
        }

        // Validate at least one result
        const times = results.find(r => r && r.hourly && r.hourly.time)?.hourly?.time || [];
        if (!times.length) throw new Error('Donn√©es horaires indisponibles');

        const now = new Date();
        let currentIndex = times.findIndex(t => new Date(t) >= now);
        if (currentIndex === -1) currentIndex = times.length - 1;
        if (currentIndex > 0) currentIndex -= 1;

        const us = new Array(nx * ny).fill(0);
        const vs = new Array(nx * ny).fill(0);
        let sumSpeed = 0, count = 0, maxSpeed = 0;

        let k = 0;
        for (let i = 0; i < ny; i++) {
          for (let j = 0; j < nx; j++) {
            const r = results[k++];
            const speeds = r?.hourly?.wind_speed_10m || [];
            const dirs = r?.hourly?.wind_direction_10m || [];
            const s = Number(speeds[currentIndex]);
            const d = Number(dirs[currentIndex]);
            if (Number.isFinite(s) && Number.isFinite(d)) {
              const { u, v } = uvFromSpeedDir(s, d);
              us[i * nx + j] = u;
              vs[i * nx + j] = v;
              sumSpeed += s; count++;
              if (s > maxSpeed) maxSpeed = s;
            }
          }
        }

        const avgSpeed = count ? sumSpeed / count : 0;
        const refTimeIso = new Date(times[currentIndex]).toISOString();

        const headerBase = {
          parameterCategory: 2,
          parameterCategoryName: 'Momentum',
          parameterUnit: 'm.s-1',
          dx: lonStep,
          dy: -latStep,
          la1: lats[0],
          la2: lats[lats.length - 1],
          lo1: lons[0],
          lo2: lons[lons.length - 1],
          nx, ny,
          refTime: refTimeIso
        };

        const windData = [
          { header: { ...headerBase, parameterNumber: 2, parameterNumberName: 'eastward_wind' }, data: us },
          { header: { ...headerBase, parameterNumber: 3, parameterNumberName: 'northward_wind' }, data: vs }
        ];

        const payload = { windData, avgSpeed, count, total: nx * ny, maxSpeed, refTimeIso };

        // persist to localStorage for faster subsequent loads
        try { saveCachedGrid(n, payload); } catch (e) { /* ignore */ }

        return payload;
      } finally {
        clearTimeout(timeout);
      }
    }

    function updateInfo({ avgSpeed, count, total, refTimeIso, maxSpeed }) {
      const coverage = ((count / total) * 100).toFixed(1);
      $info.innerHTML = `
        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
          <span><strong>Vitesse moyenne:</strong></span>
          <span><strong>${avgSpeed.toFixed(1)} m/s</strong></span>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
          <span><strong>Vitesse max:</strong></span>
          <span><strong>${maxSpeed.toFixed(1)} m/s</strong></span>
        </div>
        <div style="display: flex; justify-content: space-between;">
          <span>Couverture donn√©es:</span>
          <span>${coverage}% (${count}/${total})</span>
        </div>
      `;
      $time.textContent = new Date(refTimeIso).toLocaleString('fr-FR', {
        hour: '2-digit',
        minute: '2-digit',
        day: '2-digit',
        month: '2-digit'
      });
    }

    function renderVelocity(windData, maxVelocity) {
      if (velocityLayer) {
        map.removeLayer(velocityLayer);
        velocityLayer = null;
      }
      
      console.log(t('windData'), windData);
      console.log(t('maxVelocity'), maxVelocity);
       
      // Try to use leaflet-velocity if available
      if (L.velocityLayer && !window.velocityLibraryFailed) {
        try {
          velocityLayer = L.velocityLayer({
            data: windData,
            displayValues: true,
            displayOptions: {
              velocityType: 'Vent',
              position: 'bottomleft',
              emptyString: 'Pas de donn√©es vent',
              angleConvention: 'meteo',
              speedUnit: 'm/s',
              showCardinal: true
            },
            minVelocity: 0,
            maxVelocity: Math.max(10, Math.ceil(maxVelocity * 1.5)),
            velocityScale: 0.005,
            colorScale: [
              '#3288bd', '#66c2a5', '#abdda4', '#e6f598', 
              '#fee08b', '#fdae61', '#f46d43', '#d53e4f'
            ],
            particleAge: 64,
            particleMultiplier: 1/250,
            frameRate: 20,
            opacity: 0.97
          });
          
          velocityLayer.addTo(map);
          console.log(t('velocityAdded'));
          toast('Animation des vents activ√©e');
          return;
        } catch (err) {
          console.error(t('velocityFailed'), err);
        }
      }
      
      // Fallback to custom wind visualization
      console.log(t('usingCustom'));
      velocityLayer = createCustomWindLayer(windData, maxVelocity);
      if (velocityLayer) {
        velocityLayer.addTo(map);
        toast('Visualisation des vents (mode compatibilit√©)');
      }
    }

    async function loadAndRender(n = gridSize) {
      try {
        document.getElementById('refresh-btn').disabled = true;
        $info.innerHTML = 'Chargement des donn√©es‚Ä¶ <span class="spinner"></span>';
        
        const payload = await fetchGridData(n);
        updateInfo(payload);
        renderVelocity(payload.windData, payload.maxSpeed);
        toast(`Donn√©es vent mises √† jour (${payload.count} points)`);
      } catch (err) {
        // show friendly message to user, but keep full error in console for debugging
        const friendly = mapErrorToUserMessage(err);
        $info.innerHTML = `<div style="color: #dc2626;">${friendly}</div>`;
        toast(friendly, 4500, 'error');
      } finally {
        document.getElementById('refresh-btn').disabled = false;
      }
    }

    function startAuto() {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = setInterval(() => loadAndRender(gridSize), 30 * 60 * 1000);
    }

    // Enhanced controls with better UX
    document.getElementById('refresh-btn').addEventListener('click', () => {
      loadAndRender(gridSize);
    });

    document.getElementById('apply-grid').addEventListener('click', () => {
      const n = Number(document.getElementById('density').value);
      if (n !== gridSize) {
        gridSize = n;
        toast(`R√©solution chang√©e: ${n}√ó${n}`);
        loadAndRender(n);
      }
    });

    document.getElementById('toggle-animation').addEventListener('click', (e) => {
      animationPaused = !animationPaused;
      if (velocityLayer) {
        if (animationPaused) {
          map.removeLayer(velocityLayer);
          e.target.innerHTML = '‚ñ∂Ô∏è Reprendre';
          toast('Animation en pause');
        } else {
          map.addLayer(velocityLayer);
          e.target.innerHTML = '‚è∏Ô∏è Pause';
          toast('Animation reprise');
        }
      }
    });

    document.getElementById('fullscreen-btn').addEventListener('click', () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        document.documentElement.requestFullscreen();
      }
    });

    // Panel toggle for mobile
    $togglePanel.addEventListener('click', () => {
      $panel.classList.toggle('collapsed');
    });

    // Auto-hide panel on small screens after interaction
    if (window.innerWidth <= 768) {
      setTimeout(() => {
        $panel.classList.add('collapsed');
      }, 5000);
    }

    // Initialize
    loadAndRender(gridSize);
    startAuto();

    // Handle fullscreen changes
    document.addEventListener('fullscreenchange', () => {
      const btn = document.getElementById('fullscreen-btn');
      btn.innerHTML = document.fullscreenElement ? '‚õ∂ Quitter' : '‚õ∂ Plein √©cran';
    });

    // Handle orientation changes on mobile
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        map.invalidateSize();
      }, 500);
    });
  </script>
</body>
</html>